const helper = require('./helper')
const logger = helper.getLogger('ca-agent')
const orgName = 'BU'
const caService = helper.getCaService(orgName)
const tlscaService = helper.getTLSCAService(orgName)
const fs = require('fs')
const fsExtra = require('fs-extra')
const caUtil = require('./util/ca')
const globalConfig = require('../config/orgs.json')
const COMPANY = 'delphi'
const companyConfig = globalConfig[COMPANY]
// caUtil.generateKey(client.getCryptoSuite()).then((result)=>{
const CRYPTO_CONFIG_DIR = companyConfig.docker.volumes.MSPROOT.dir
const COMPANY_DOMAIN = companyConfig.domain
const orgsConfig = companyConfig.orgs
const caConfig = orgsConfig[orgName].ca

const clientUtil = require('./util/client')

const path = require('path')
const client = helper.getClient()
clientUtil.setDefaultCryptoSuite(client)

const peerName = 'peerF'

/**
 *
 * @param peerName
 * @param orgName
 * @param {boolean} isTLS  true=>TLS, false=>MSP
 */
const genPeer = ({ peerName, orgName }, isTLS = false) => {
	const org_domain = `${orgName}.${COMPANY_DOMAIN}`

	const orgPath = path.join(CRYPTO_CONFIG_DIR, 'peerOrganizations', org_domain)
	const baseDir = isTLS ? 'tls' : 'msp'
	const boundCA = isTLS ? tlscaService : caService
	//this admin is not generated by cryptogen
	const adminName = caConfig.admin.name
	const adminPass = caConfig.admin.pass

	const adminRoot = path.join(orgPath, 'users', helper.formatUsername(adminName, orgName), baseDir)
	const MSPID = orgsConfig[orgName].MSP.id
	let adminUserPromise
	const signcertFile = path.join(adminRoot, 'signcerts', `${helper.formatUsername(adminName, orgName)}-cert.pem`)
	if (fs.existsSync(signcertFile)) {
		//load from file
		if (isTLS) {
			adminUserPromise = helper.userAction.tlsCreate(adminRoot, adminName, orgName, MSPID, false)
		} else {
			const keystoreDir = path.join(adminRoot, 'keystore')

			adminUserPromise = helper.userAction.mspCreate(keystoreDir, signcertFile, adminName, orgName, MSPID, false)
		}

	} else {
		adminUserPromise = caUtil.enroll(boundCA, { enrollmentID: adminName, password: adminPass }).
				then((result) => {
					fsExtra.ensureDirSync(adminRoot)
					if (isTLS) {
						const tlscacerts = path.join(orgPath, 'users', helper.formatUsername(adminName, orgName), 'msp',
								'tlscacerts')
						fsExtra.ensureDirSync(tlscacerts)
						fs.writeFileSync(path.join(tlscacerts, `tlsca.${org_domain}-cert.pem`), result.rootCertificate)
						caUtil.toTLS(result, adminRoot)
					} else {

						caUtil.admin.toMSP(result, adminRoot, { adminName, domain: org_domain })
					}
					return caUtil.user.build(helper.formatUsername(adminName, orgName), result, MSPID).then((user) => {

						return client.setUserContext(user, true)
					})
				})
	}

	return adminUserPromise.then((adminUser) => {

		const rootDir = path.join(orgPath, 'peers', helper.formatPeerName(peerName, orgName), baseDir)
		fsExtra.ensureDirSync(rootDir)
		const passwordFile = `${rootDir}/pwdFile` // fixme: file with password content security issue
		const affiliation = orgName.toLowerCase()
		return caUtil.peer.register(boundCA, { peerName, affiliation }, adminUser).
				then((password) => {
					fs.writeFileSync(passwordFile, password)
					return caUtil.peer.enroll(boundCA, { peerName, password })
				}).
				catch(err => {
					if (err.toString().includes('"code":0')) {
						logger.warn(err)
						const password = fs.readFileSync(passwordFile)
						//[[{"code":0,"message":"Identity 'peerF' is already registered"}]]
						return caUtil.peer.enroll(boundCA, { peerName, password })
					} else {
						return Promise.reject(err)
					}
				}).
				then((result) => {
					if (isTLS) {
						const checkpoint = path.join(rootDir, 'server.key')
						if (fs.existsSync(checkpoint)) {
							logger.warn(`${checkpoint} already exist, skipping`)
							return Promise.resolve()
						}
						caUtil.toTLS(result, rootDir)
						const tlscacerts = path.join(orgPath, 'peers', helper.formatPeerName(peerName, orgName), 'msp',
								'tlscacerts')
						fsExtra.ensureDirSync(tlscacerts)
						fs.writeFileSync(path.join(tlscacerts, `tlsca.${org_domain}-cert.pem`), result.rootCertificate)
					} else {
						const checkpoint = path.join(rootDir, 'signcerts', `${peerName}.${org_domain}-cert.pem`)
						if (fs.existsSync(checkpoint)) {
							logger.warn(`${checkpoint} already exist... skipping`)
							return Promise.resolve()
						}
						caUtil.peer.toMSP(result, rootDir, { peerName, org_domain })
					}

					return Promise.resolve()
				})

	})
}
exports.genPeerMSP = ({ peerName, orgName }) => {genPeer({ peerName, orgName }, false)}
exports.genPeerTLS = ({ peerName, orgName }) => {genPeer({ peerName, orgName }, true)}
genPeer({ peerName, orgName }, true)
genPeer({ peerName, orgName }, false)