const helper = require('./helper')
const logger = helper.getLogger('ca-agent')

const fs = require('fs')
const fsExtra = require('fs-extra')
const caUtil = require('./util/ca')
const globalConfig = require('../config/orgs.json')
const COMPANY = 'delphi'
const companyConfig = globalConfig[COMPANY]
// caUtil.generateKey(client.getCryptoSuite()).then((result)=>{
const CRYPTO_CONFIG_DIR = companyConfig.docker.volumes.MSPROOT.dir
const COMPANY_DOMAIN = companyConfig.domain
const orgsConfig = companyConfig.orgs

const path = require('path')
const client = helper.getClient()
if (!client.getCryptoSuite()) {
	require('./util/client').setDefaultCryptoSuite(client)
}

/**
 *
 * @param peerName
 * @param orgName
 * @param {boolean} isTLS  true=>TLS, false=>MSP
 */
const genPeer = ({ peerName, orgName }, isTLS = false) => {
	const org_domain = `${orgName}.${COMPANY_DOMAIN}`
	const caConfig = orgsConfig[orgName].ca

	const caService = helper.getCaService(orgName)
	const tlscaService = helper.getTLSCAService(orgName)

	const orgPath = path.join(CRYPTO_CONFIG_DIR, 'peerOrganizations', org_domain)
	const orgMSPPath = path.join(orgPath, 'msp')
	const targetDir = isTLS ? 'tls' : 'msp'
	const boundCA = isTLS ? tlscaService : caService
	//this admin is not generated by cryptogen
	const CAadminName = caConfig.admin.name
	const CAadminPass = caConfig.admin.pass

	const peerRoot = path.join(orgPath, 'peers', helper.formatPeerName(peerName, orgName))
	const peerMSP = path.join(peerRoot, 'msp')
	const peerTarget = path.join(peerRoot, targetDir)
	const adminRoot = path.join(orgPath, 'users', helper.formatUsername(CAadminName, orgName))
	const adminMSP = path.join(adminRoot, 'msp')
	const adminTarget = path.join(adminRoot, targetDir)
	const MSPID = orgsConfig[orgName].MSP.id
	let adminUserPromise
	const signcertFile = path.join(adminTarget, 'signcerts', `${helper.formatUsername(CAadminName, orgName)}-cert.pem`)
	if (fs.existsSync(signcertFile)) {
		//load from file
		if (isTLS) {
			adminUserPromise = helper.userAction.tlsCreate(adminTarget, CAadminName, orgName, MSPID, false)
		} else {
			const keystoreDir = path.join(adminTarget, 'keystore')

			adminUserPromise = helper.userAction.mspCreate(keystoreDir, signcertFile, CAadminName, orgName, MSPID, false)
		}

	} else {
		adminUserPromise = caUtil.enroll(boundCA, { enrollmentID: CAadminName, enrollmentSecret:CAadminPass }).
				then((result) => {
					fsExtra.copySync(orgMSPPath, adminMSP)
					fsExtra.ensureDirSync(adminTarget)
					if (isTLS) {
						caUtil.toTLS(result, adminTarget)
					} else {

						caUtil.admin.toMSP(result, adminTarget, { adminName: CAadminName, domain: org_domain })
					}

					return caUtil.user.build(helper.formatUsername(CAadminName, orgName), result, MSPID).then((user) => {

						return client.setUserContext(user, true)
					})
				})
	}

	return adminUserPromise.then((adminUser) => {

		fsExtra.ensureDirSync(peerTarget)
		const passwordFile = `${peerTarget}/pwdFile` // fixme: file with password content security issue
		const affiliation = orgName.toLowerCase()
		return caUtil.peer.register(boundCA, { peerName: helper.formatPeerName(peerName, orgName), affiliation },
				adminUser).
				then((password) => {
					fs.writeFileSync(passwordFile, password)
					return caUtil.peer.enroll(boundCA, { peerName: helper.formatPeerName(peerName, orgName), password })
				}).
				catch(err => {
					if (err.toString().includes('"code":0')) {
						logger.warn(err)
						const password = fs.readFileSync(passwordFile)
						//[[{"code":0,"message":"Identity 'peerF' is already registered"}]]
						return caUtil.peer.enroll(boundCA, { peerName: helper.formatPeerName(peerName, orgName), password })
					} else {
						return Promise.reject(err)
					}
				}).
				then((result) => {
					if (isTLS) {
						const checkpoint = path.join(peerTarget, 'server.key')
						if (fs.existsSync(checkpoint)) {
							logger.warn(`${checkpoint} already exist, skipping`)
							return Promise.resolve()
						}
						caUtil.toTLS(result, peerTarget)

					} else {
						const checkpoint = path.join(peerTarget, 'signcerts',
								`${helper.formatPeerName(peerName, orgName)}-cert.pem`)
						if (fs.existsSync(checkpoint)) {
							logger.warn(`${checkpoint} already exist... skipping`)
							return Promise.resolve()
						}
						caUtil.peer.toMSP(result, peerTarget, { peerName, org_domain })
					}
					fsExtra.copySync(orgMSPPath, peerMSP)

					return Promise.resolve()
				})

	})
}
exports.genPeerMSP = ({ peerName, orgName }) => genPeer({ peerName, orgName }, false)
exports.genPeerTLS = ({ peerName, orgName }) => genPeer({ peerName, orgName }, true)
